<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Some blog</title>
    <link>http://odushyn.github.io/</link>
    <description>Recent content on Some blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 10 Jul 2018 23:31:01 +0200</lastBuildDate>
    <atom:link href="http://odushyn.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>The main idea behind rxjs</title>
      <link>http://odushyn.github.io/post/rxjs-main-concept/</link>
      <pubDate>Tue, 10 Jul 2018 23:31:01 +0200</pubDate>
      
      <guid>http://odushyn.github.io/post/rxjs-main-concept/</guid>
      <description>

&lt;h3 id=&#34;what-is-rxjs&#34;&gt;What is rxjs?&lt;/h3&gt;

&lt;p&gt;ReactiveX is a library for composing asynchronous and event-based programs by using observable sequences.
rxjs is implimentation  Observer pattern in javascript programming language (&lt;a href=&#34;http://reactivex.io/intro.html&#34;&gt;source&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Not clear yet&amp;hellip;&lt;/p&gt;

&lt;p&gt;All my following examples are taken from &lt;a href=&#34;https://rxjs-dev.firebaseapp.com/guide/overview&#34;&gt;official guide&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&#34;first-example-create-observable&#34;&gt;First example: create observable&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Count how many times the button was clicked.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Straightforward solution via using event listener and implementing callback function.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var count = 0;
var button = document.querySelector(&#39;button&#39;);
button.addEventListener(&#39;click&#39;, () =&amp;gt; console.log(`Clicked ${++count} times`));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is big disadvantage: callback function modifies external state - &lt;code&gt;count&lt;/code&gt; variable.
In big projects such behaviour may lead to unexpected errors.&lt;/p&gt;

&lt;p&gt;In example above we handle each event separately. However, what if we could handle the flow of these events?
This idea is implemented inside Observable object. Observable object emits events and gives possibility to
manipulate them in sequential way.&lt;/p&gt;

&lt;p&gt;There are many ways to create an Observable out of html events flow. Let&amp;rsquo;s use &lt;code&gt;fromEvent&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let observable = fromEvent(button, &#39;click&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once we have an Observable that emit events we also need the way to consume those events.
Here is where Observer comes to play. We observe emitted values using &lt;code&gt;subscribe&lt;/code&gt; method.
Subscribe method consumes 3 callbacks: for success consumes event, error consumes error
and onComplete callback consumes nothing.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let observable = fromEvent(button, &#39;click&#39;);
let subscription = observable.subscribe((event) =&amp;gt; {}, (error) =&amp;gt; {}, () =&amp;gt; {})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Method subscribe returns &lt;code&gt;Subscription&lt;/code&gt; object the mainly used for canceling subscription
by calling &lt;code&gt;subscription.unsubscribe()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Based &lt;em&gt;ONLY&lt;/em&gt; on this knowledge we may implement next solution(&lt;em&gt;ugly, DO NOT repeat this&lt;/em&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let count = 0;
const button = document.querySelector(&#39;button&#39;);
fromEvent(button, &#39;click&#39;).subscribe(count =&amp;gt; {
    console.log(`RXJS: Clicked ${count++} times`)
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Where the benefit of using Observable you may ask? After all, we still have global count variable.&lt;/p&gt;

&lt;p&gt;What if we could manipulate the flow itself and change each events or values emitted by Observable before getting it
into subscribe function as parameter?
There is where a very power concept of Operators comes to play at this exact moment.
To solve our problem we may use &lt;code&gt;scan&lt;/code&gt; operator.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const button = document.querySelector(&#39;button&#39;);
fromEvent(button, &#39;click&#39;).pipe(
  scan(count =&amp;gt; count + 1, 0)
)
.subscribe(count =&amp;gt; console.log(`RXJS: Clicked ${count} times`));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;scan&lt;/code&gt; operator implements callback function and aggregates the result into count variable.&lt;/p&gt;

&lt;p&gt;Since rxjs-v6 it&amp;rsquo;s mandatory to use &lt;code&gt;pipe&lt;/code&gt; method and pass operators inside it as its parameters.
Thus, before you get emitted event inside &lt;code&gt;subscribe&lt;/code&gt; function all events go through the &lt;code&gt;pipe&lt;/code&gt; and
gets modified by the specified operators.&lt;/p&gt;

&lt;p&gt;Last solution by using &lt;code&gt;observable&lt;/code&gt; and &lt;code&gt;scan&lt;/code&gt; operators provides clean solution without using global variables
and you can easily scale it.&lt;/p&gt;

&lt;h4 id=&#34;second-example-apply-operator&#34;&gt;Second example: apply operator&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;The task is to allow and handle at most one click per second.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Straightforward solution:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var count = 0;
var rate = 1000;
var lastClick = Date.now() - rate;
var button = document.querySelector(&#39;button&#39;);
button.addEventListener(&#39;click&#39;, () =&amp;gt; {
  if (Date.now() - lastClick &amp;gt;= rate) {
    console.log(`Clicked ${++count} times`);
    lastClick = Date.now();
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using observables:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const { fromEvent } = rxjs;
const { throttleTime, scan } = rxjs.operators;
const button = document.querySelector(&#39;button&#39;);
fromEvent(button, &#39;click&#39;).pipe(
  throttleTime(1000),
  scan(count =&amp;gt; count + 1, 0)
)
.subscribe(count =&amp;gt; console.log(`Clicked ${count} times`));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Just look at how is readable the solution that uses observables. That is because it allows to control the flow.
&lt;code&gt;throttleTime&lt;/code&gt; operator emits latest value when specified duration has passed and &lt;code&gt;scan&lt;/code&gt; operator counts the
total number of events.
Operators are executed in the order they specified inside pipe function. Scan operator is not executed until
&lt;code&gt;throttleTime&lt;/code&gt; emits the value. &lt;code&gt;subscribe&lt;/code&gt; function is not executed until all operators are passed.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://image.slidesharecdn.com/fpjsluisatenciobocajs-160504163409/95/luis-atencio-on-rxjs-22-638.jpg?cb=1462379809&#34;&gt;&lt;/p&gt;

&lt;h4 id=&#34;third-example-scale-existing-solution&#34;&gt;Third example: scale existing solution&lt;/h4&gt;

&lt;p&gt;Lets make task more complicated and count the sum of current mouse x positions.
Event listener:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let count = 0;
const rate = 1000;
let lastClick = Date.now() - rate;
const button = document.querySelector(&#39;button&#39;);
button.addEventListener(&#39;click&#39;, (event) =&amp;gt; {
  if (Date.now() - lastClick &amp;gt;= rate) {
    count += event.clientX;
    console.log(count)
    lastClick = Date.now();
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Observable:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const { fromEvent } = rxjs;
const { throttleTime, map, scan } = rxjs.operators;

const button = document.querySelector(&#39;button&#39;);
fromEvent(button, &#39;click&#39;).pipe(
  throttleTime(1000),
  map(event =&amp;gt; event.clientX),
  scan((count, clientX) =&amp;gt; count + clientX, 0)
)
.subscribe(count =&amp;gt; console.log(count));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Event listener solution required refactoring of the algorithm but Observable approach
adding of one more operator - &lt;code&gt;map&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;map&lt;/code&gt; transforms the items emitted by an Observable by applying a function to each item.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Firstly, click happened by user and click event was emitted by browser.&lt;/li&gt;
&lt;li&gt;The flow of click events is handled by our Observable. Observable emits same event further.&lt;/li&gt;
&lt;li&gt;Then this event is processed via the pipe. &lt;code&gt;throttleTime&lt;/code&gt; checks whether one second passed and if
so emits click event further to &lt;code&gt;map&lt;/code&gt; operator.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;map&lt;/code&gt; is transform operator and in our case it transforms click event(object) to coordinate(number).
Therefore, scan get number as input instead of event object.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Browser click(emits Event() object) -&amp;gt; Observable(Event()) -&amp;gt;
-&amp;gt; Pipe[throttleTime(Event()) -&amp;gt; map(number) -&amp;gt; scan(number)] -&amp;gt; subscribe(number).&lt;/p&gt;

&lt;p&gt;Note: &lt;code&gt;scan&lt;/code&gt; first parameter is always aggregated value and the second one is emitted value.&lt;/p&gt;

&lt;p&gt;Conclusion: rxjs is (almost as any other library) just helps to solve same problems in different way.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;introduces an abstraction for managing flows of events(first example) and the concept of Observable,
Observer, Subscription operators and creates.&lt;/li&gt;
&lt;li&gt;helps to solve event based tasks rather in a declarative
than imperative way.&lt;/li&gt;
&lt;li&gt;code becomes more readable and programmer mainly thinks about which operators to apply instead of implementing
algorithms(2nd and 3rd examples).&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Privacy Policy</title>
      <link>http://odushyn.github.io/projects/quizbot/privacy-policy/</link>
      <pubDate>Mon, 02 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>http://odushyn.github.io/projects/quizbot/privacy-policy/</guid>
      <description>

&lt;h1 id=&#34;quizbot-privacy-policy&#34;&gt;QuizBot Privacy Policy&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;Last updated: 04.02.2018&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Privacy Policy informs users of the policies and procedures regarding the collection, use and disclosure of information received from users of this service.&lt;/p&gt;

&lt;h2 id=&#34;information-collection-and-use&#34;&gt;Information Collection and Use&lt;/h2&gt;

&lt;p&gt;In order to use QuizBot you must be authenticated via Facebook. The only personal data this service keeps are user name and facebook id.
This data is needed to communicate with you. It may be kept in system logs in order to provide customer support and
in the database to enhance the service and it&amp;rsquo;s features.&lt;/p&gt;

&lt;h2 id=&#34;use-of-contact-information&#34;&gt;Use of Contact Information&lt;/h2&gt;

&lt;p&gt;We don&amp;rsquo;t use your contact information.&lt;/p&gt;

&lt;h2 id=&#34;changes-to-this-policy&#34;&gt;Changes to this Policy&lt;/h2&gt;

&lt;p&gt;This Privacy Policy may be updated from time to time for any reason.
We will notify you of any modifications to our Privacy Policy by posting the message on our main Facebook page and/or notifying you via facebook messenger.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Projects</title>
      <link>http://odushyn.github.io/projects/</link>
      <pubDate>Mon, 02 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>http://odushyn.github.io/projects/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.facebook.com/Quize-1754836161485411/&#34;&gt;QuizBot&lt;/a&gt; - facebook messenger bot for playing quizzes (&lt;a href=&#34;https://github.com/ODushyn/fb-quiz-bot&#34;&gt;GitHub&lt;/a&gt;).&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>About</title>
      <link>http://odushyn.github.io/about/</link>
      <pubDate>Sat, 20 Jun 2015 14:02:37 +0200</pubDate>
      
      <guid>http://odushyn.github.io/about/</guid>
      <description>&lt;p&gt;I am a software engineer.&lt;/p&gt;

&lt;p&gt;I mostly use Java and Javascript stacks for development.&lt;/p&gt;

&lt;p&gt;Besides, I enjoy playing table tennis, chess and snowboarding.&lt;/p&gt;

&lt;p&gt;Email me:  &lt;a href=&#34;mailto:wo.dushyn@gmail.com&#34;&gt;wo.dushyn@gmail.com&lt;/a&gt; or find me by clicking on any link bellow.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://odushyn.github.io/post/rxjs-main-operators/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://odushyn.github.io/post/rxjs-main-operators/</guid>
      <description></description>
    </item>
    
    <item>
      <title>State Pattern. JavaScript implementation.</title>
      <link>http://odushyn.github.io/post/state-pattern-js/</link>
      <pubDate>Sun, 05 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>http://odushyn.github.io/post/state-pattern-js/</guid>
      <description>

&lt;h3 id=&#34;introduction&#34;&gt;Introduction:&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/State_pattern&#34;&gt;According to wikipedia&lt;/a&gt; it is a behavioral software design pattern that
implements a &lt;em&gt;state machine&lt;/em&gt; in an object-oriented way.&lt;/p&gt;

&lt;p&gt;What&amp;rsquo;s &lt;em&gt;state machine&lt;/em&gt;?
Finite State Machine(FSM) is some abstract machine that can be in exactly one state at particular moment of time and
has rules for changing the states(making transition).&lt;/p&gt;

&lt;p&gt;Basically, FSM can be defined by 3 things:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;list of states&lt;/li&gt;
&lt;li&gt;rules for chaning the states&lt;/li&gt;
&lt;li&gt;initial state&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;examples&#34;&gt;Examples&lt;/h3&gt;

&lt;p&gt;We interact with state machines every day.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;traffic lights&lt;/li&gt;
&lt;li&gt;elevators&lt;/li&gt;
&lt;li&gt;ticket machines&lt;/li&gt;
&lt;li&gt;minibanks&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;defining-traffic-light-as-state-machine&#34;&gt;Defining traffic light as state machine&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;List of states: green/yellow/red&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Rules:&lt;/p&gt;

&lt;p&gt;-if light is green move to yellow condition.&lt;/p&gt;

&lt;p&gt;-if light is yellow move to red condition.&lt;/p&gt;

&lt;p&gt;-if light is red move to green condition&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Initial state: green.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;implementation-without-state-pattern&#34;&gt;Implementation without state pattern&lt;/h3&gt;

&lt;p&gt;Before using state pattern itself let&amp;rsquo;s try to implement traffic light logic straightforward. We are going to create
object &lt;em&gt;State&lt;/em&gt; that will represents traffic lights(green, yellow or red) and use if/else statements to handle lights
changing.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function LightMachine(light) {
  // current state  
  this.light = light;
  printInfo(this.light);
  
  this.changeLight = function() {
    // transition rules  
    if (this.light === &amp;quot;GREEN&amp;quot;) {
      this.light = &amp;quot;YELLOW&amp;quot;;
    } else if (this.light === &amp;quot;YELLOW&amp;quot;) {
      this.light = &amp;quot;RED&amp;quot;;
    } else if (this.light === &amp;quot;RED&amp;quot;) {
      this.light = &amp;quot;GREEN&amp;quot;;
    }
    printInfo(this.light);
  };
  
  function printInfo(light){
    console.log(&#39;Current light: &#39; + light);
  }
}

// create initial state &#39;GREEN&#39;
var lightMachine = new LightMachine(&#39;GREEN&#39;);
lightMachine.changeLight(); // YELLOW
lightMachine.changeLight(); // RED
lightMachine.changeLight(); // GREEN
lightMachine.changeLight(); // YELLOW
lightMachine.changeLight(); // RED
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Everything looks great except the branched out and coupled code in the rules part. Considering more complex example, you will get
more different and complicated if/else statements which makes code even less readable and maintainable.&lt;/p&gt;

&lt;h3 id=&#34;implementation-with-state-pattern&#34;&gt;Implementation with state pattern&lt;/h3&gt;

&lt;p&gt;So, let&amp;rsquo;s try to decouple this code.&lt;/p&gt;

&lt;p&gt;The reason of such branching code is that we try to handle all transition logic in one place. Let&amp;rsquo;s make it different way,
so each state keeping its transition rules logic by itself.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let Green = function() {
  this.name = &amp;quot;Green&amp;quot;;
  this.transition = function(trafficLight) {
    trafficLight.setLight(new Yellow());
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We have created an object that encapsulates(holds) all particular state internal data(i.e. state name)
and implements common for all states function &lt;em&gt;transition&lt;/em&gt; that contains rules.
The same should be done for each state. Basically, state object by itself only answers the question:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&amp;ldquo;What must be the next state according to the defined rules?&amp;rdquo;&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let Yellow = function() {
  this.name = &amp;quot;Yellow&amp;quot;;
  this.transition = function(trafficLight) {
    // according to the rules next state should be Red
    trafficLight.setLight(new Red());
  }
};

let Red = function(trafficLight) {
  this.name = &amp;quot;Red&amp;quot;;
  // according to the rules next state should be Green
  this.transition = function(trafficLight) {
    trafficLight.setLight(new Green());
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are done with states, but we need to be able to start, stop the system, put system in the specified state,
keep the particular state, implement any logic between the transitions.
We also would like to know answers on following questions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;What is the current state of the system?&lt;/li&gt;
&lt;li&gt;What are the statistics (how many times states are changed, what state is the most &amp;ldquo;popular&amp;rdquo;, etc)?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Let&amp;rsquo;s create a function for that exact reason. People usually  call it &lt;em&gt;context&lt;/em&gt; object because it keeps information
that&amp;rsquo;s common and available for each state.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let TrafficLight = function(initialState) {
  this.currentState = initialState;
  
  this.setLight = function(newLight) {
    this.currentState = newLight;
    console.log(&#39;Current state: &#39; + this.currentState.name);
  }
  this.changeLight = function() {
    this.currentState.transition(this);
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we see it contains two methods. &lt;em&gt;setLight&lt;/em&gt; sets the current traffic light and &lt;em&gt;changeLight&lt;/em&gt; is responsible
for transition according to the current state&amp;rsquo;s rules. The rules are encapsulated in each state object.
Therefore, we do not have if/else hell and spaghetti code anymore&lt;/p&gt;

&lt;p&gt;&lt;em&gt;There is only one interface(TrafficLight) which contains current state and delegates implementation of transitions to state objects.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Code looks much more readable and cleaner than in the first approach. This approach is called &amp;ldquo;State pattern&amp;rdquo;.
We are ready to use our traffic light implemented via &lt;em&gt;State Pattern&lt;/em&gt; now!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var stateContext = new TrafficLight(new Green());
stateContext.changeLight();
stateContext.changeLight();
stateContext.changeLight();
stateContext.changeLight();
stateContext.changeLight();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Check out &lt;a href=&#34;http://plnkr.co/edit/iJo6CfGjX0EuiZ9BIj4l&#34;&gt;plunker&lt;/a&gt; to see full version.&lt;/p&gt;

&lt;h3 id=&#34;smart-traffic-light&#34;&gt;Smart traffic light&lt;/h3&gt;

&lt;p&gt;I&amp;rsquo;ve added timing for switching between the lights to make our traffic light more real.
Check out &lt;a href=&#34;http://plnkr.co/edit/V5bUWp&#34;&gt;this plunk&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Hope you enjoyed reading!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>HTTP. How to return errors to clients?</title>
      <link>http://odushyn.github.io/post/http-return-errors-to-clients/</link>
      <pubDate>Wed, 18 May 2016 00:00:00 +0000</pubDate>
      
      <guid>http://odushyn.github.io/post/http-return-errors-to-clients/</guid>
      <description>

&lt;p&gt;HTTP is based on the exchange of representations.
Errors are not an exception.
Whenever error happens on a server either because of wrong request or server internal problems - &lt;em&gt;always&lt;/em&gt; return a representation that reflects the current state of the error.&lt;/p&gt;

&lt;p&gt;Response must contain:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Response code&lt;/li&gt;
&lt;li&gt;Body containing the error description.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;response-code&#34;&gt;Response code&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Helps clients to understand the reason why error happened&lt;/p&gt;

&lt;p&gt;Return &lt;em&gt;4xx&lt;/em&gt; status code for errors due to client inputs, &lt;em&gt;5xx&lt;/em&gt; - for errors due to server implementation.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Keeps interacting correctly &amp;ldquo;visible&amp;rdquo; for middle-ware software&lt;/p&gt;

&lt;p&gt;Common mistake is to return success status code (200 - 206 and 300 - 307) for error describing.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;    HTTP/1.1 200 OK
    Content-Type: application/xml
    
    &amp;lt;error&amp;gt;
        &amp;lt;message&amp;gt;There are no free seats left&amp;lt;/message&amp;gt;
    &amp;lt;/error&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Doing this prevents HTTP-aware software from detecting errors.
For example, a cache will store it as a successful response and serve it to subsequent clients even when clients may be able to make a successful request.&lt;/p&gt;

&lt;p&gt;Client can rely on error status returned by a server. Client error handling may looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    if(response.code &amp;gt;= 400 and response.code &amp;lt; 400) {
        // Failure due to client error
        ...
    }
    else if(response.code &amp;gt;= 500) {
        // Failure due to server error
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Errors due to client inputs (the most often used ones):&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;400 (Bad Request)&lt;/em&gt; - return this error when your server cannot decipher client requests because of syntactical errors.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;401 (Unauthorized)&lt;/em&gt; - return this when the client is not authorized to access the resource but may be able to gain access after authentication.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;403 (Forbidden)&lt;/em&gt; - use this when your server will not let the client gain access to the resource and
authentication will not help. For instance, you can return this when the user is already authenticated but is not
allowed to request a resource.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;404 (Not Found)&lt;/em&gt; - return this when the resource is not found. If possible, specify a reason in the
message body.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;405 (Not Allowed)&lt;/em&gt; - return this when an HTTP method is not allowed for this resource.
Return an Allow header with methods that are valid for this resource.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;409 (Conflict)&lt;/em&gt; - return this when the request conflicts with the current state of the resource. Include
a body explaining the reason.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;410 (Gone)&lt;/em&gt; - return this when the resource used to exist, but it does not anymore (if you don&amp;rsquo;t keep track of deleted files on a server then just return 404).&lt;/li&gt;
&lt;li&gt;&lt;em&gt;413 (Request Entity Too Large)&lt;/em&gt; - return this when the body of a POST of PUT request is too large. If possible, specify what is allowed in the body, and provide alternatives.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;415 (Unsupported Media Type)&lt;/em&gt; - return this error when a client sends the message body in a format that the server
does not understand.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Error due to server error (the most often used ones):&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;500 (Internal Server Error)&lt;/em&gt; - this is the best code to return when your code on the server side failed due to some    implementation bug.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;503 (Service Unavailable)&lt;/em&gt; - return this when the server cannot fulfil the request either for some specific interval
or for an undetermined amount of time.
Two common conditions that prompt this error are failures with back-end servers
(such as a database connection failure) or when the client exceeded some rate limit
set by the server.
If possible, include a Retry-After response header with either a date or a number
of seconds as a hint.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;response-body&#34;&gt;Response body&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;Describes the error in a plain text or human readable HTML.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The body must contain enough information to understand why the error occurred and how it can be fixed by the client.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Provide a link to the documentation with error detailed description if the one exist.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;If you are logging errors on a server side provide a link that can be used to refer to this error.&lt;/li&gt;
&lt;li&gt;Keep the response body descriptive, but exclude details such as stack traces, errors from
database connection failures, etc.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I prefer using the next template:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
    message: Impossible to order a seat
    description: There are no free seats left
    code: 1000
    link: http://myproject/documentation/seats/ordering
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;code&lt;/em&gt; is a identifier for an error message. It makes possible maintaining different translations for each error message on a client side for example.&lt;/p&gt;

&lt;h4 id=&#34;references&#34;&gt;References&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;RESTful Web Services Cookbook (O&amp;rsquo;Reilly Media) by Subbu Allamaraju






&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>